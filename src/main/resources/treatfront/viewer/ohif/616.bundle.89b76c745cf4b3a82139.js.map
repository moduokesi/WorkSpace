{"version":3,"file":"616.bundle.89b76c745cf4b3a82139.js","mappings":"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","sources":["webpack:///../../../extensions/cornerstone-dicom-seg/src/id.js","webpack:///../../../extensions/cornerstone-dicom-seg/src/getSopClassHandlerModule.js","webpack:///../../../extensions/cornerstone-dicom-seg/src/panels/callInputDialog.tsx","webpack:///../../../extensions/cornerstone-dicom-seg/src/panels/PanelSegmentation.tsx","webpack:///../../../extensions/cornerstone-dicom-seg/src/getHangingProtocolModule.ts","webpack:///../../../extensions/cornerstone-dicom-seg/src/index.tsx"],"sourcesContent":["import packageJson from '../package.json';\n\nconst id = packageJson.name;\nconst SOPClassHandlerName = 'dicom-seg';\nconst SOPClassHandlerId = `${id}.sopClassHandlerModule.${SOPClassHandlerName}`;\n\nexport { id, SOPClassHandlerId, SOPClassHandlerName };\n","import vtkMath from '@kitware/vtk.js/Common/Core/Math';\n\nimport { utils } from '@ohif/core';\n\nimport { SOPClassHandlerId } from './id';\nimport dcmjs from 'dcmjs';\n\nconst { DicomMessage, DicomMetaDictionary } = dcmjs.data;\n\nconst sopClassUids = ['1.2.840.10008.5.1.4.1.1.66.4'];\n\nlet loadPromises = {};\n\nfunction _getDisplaySetsFromSeries(\n  instances,\n  servicesManager,\n  extensionManager\n) {\n  const instance = instances[0];\n\n  const {\n    StudyInstanceUID,\n    SeriesInstanceUID,\n    SOPInstanceUID,\n    SeriesDescription,\n    SeriesNumber,\n    SeriesDate,\n    SOPClassUID,\n    wadoRoot,\n    wadoUri,\n    wadoUriRoot,\n  } = instance;\n\n  const displaySet = {\n    Modality: 'SEG',\n    loading: false,\n    isReconstructable: true, // by default for now since it is a volumetric SEG currently\n    displaySetInstanceUID: utils.guid(),\n    SeriesDescription,\n    SeriesNumber,\n    SeriesDate,\n    SOPInstanceUID,\n    SeriesInstanceUID,\n    StudyInstanceUID,\n    SOPClassHandlerId,\n    SOPClassUID,\n    referencedImages: null,\n    referencedSeriesInstanceUID: null,\n    referencedDisplaySetInstanceUID: null,\n    isDerivedDisplaySet: true,\n    isLoaded: false,\n    isHydrated: false,\n    segments: {},\n    sopClassUids,\n    instance,\n    instances: [instance],\n    wadoRoot,\n    wadoUriRoot,\n    wadoUri,\n    isOverlayDisplaySet: true,\n  };\n\n  const referencedSeriesSequence = instance.ReferencedSeriesSequence;\n\n  if (!referencedSeriesSequence) {\n    throw new Error('ReferencedSeriesSequence is missing for the SEG');\n  }\n\n  const referencedSeries = referencedSeriesSequence[0];\n\n  displaySet.referencedImages =\n    instance.ReferencedSeriesSequence.ReferencedInstanceSequence;\n  displaySet.referencedSeriesInstanceUID = referencedSeries.SeriesInstanceUID;\n\n  displaySet.getReferenceDisplaySet = () => {\n    const { displaySetService } = servicesManager.services;\n    const referencedDisplaySets = displaySetService.getDisplaySetsForSeries(\n      displaySet.referencedSeriesInstanceUID\n    );\n\n    if (!referencedDisplaySets || referencedDisplaySets.length === 0) {\n      throw new Error('Referenced DisplaySet is missing for the SEG');\n    }\n\n    const referencedDisplaySet = referencedDisplaySets[0];\n\n    displaySet.referencedDisplaySetInstanceUID =\n      referencedDisplaySet.displaySetInstanceUID;\n\n    // Todo: this needs to be able to work with other reference volumes (other than streaming) such as nifti, etc.\n    displaySet.referencedVolumeURI = referencedDisplaySet.displaySetInstanceUID;\n    const referencedVolumeId = `cornerstoneStreamingImageVolume:${displaySet.referencedVolumeURI}`;\n    displaySet.referencedVolumeId = referencedVolumeId;\n\n    return referencedDisplaySet;\n  };\n\n  displaySet.load = async ({ headers }) =>\n    await _load(displaySet, servicesManager, extensionManager, headers);\n\n  return [displaySet];\n}\n\nfunction _load(segDisplaySet, servicesManager, extensionManager, headers) {\n  const { SOPInstanceUID } = segDisplaySet;\n  const { segmentationService } = servicesManager.services;\n\n  if (\n    (segDisplaySet.loading || segDisplaySet.isLoaded) &&\n    loadPromises[SOPInstanceUID] &&\n    _segmentationExists(segDisplaySet, segmentationService)\n  ) {\n    return loadPromises[SOPInstanceUID];\n  }\n\n  segDisplaySet.loading = true;\n\n  // We don't want to fire multiple loads, so we'll wait for the first to finish\n  // and also return the same promise to any other callers.\n  loadPromises[SOPInstanceUID] = new Promise(async (resolve, reject) => {\n    if (\n      !segDisplaySet.segments ||\n      Object.keys(segDisplaySet.segments).length === 0\n    ) {\n      const segments = await _loadSegments(\n        extensionManager,\n        segDisplaySet,\n        headers\n      );\n\n      segDisplaySet.segments = segments;\n    }\n\n    const suppressEvents = true;\n    segmentationService\n      .createSegmentationForSEGDisplaySet(segDisplaySet, null, suppressEvents)\n      .then(() => {\n        segDisplaySet.loading = false;\n        resolve();\n      })\n      .catch(error => {\n        segDisplaySet.loading = false;\n        reject(error);\n      });\n  });\n\n  return loadPromises[SOPInstanceUID];\n}\n\nasync function _loadSegments(extensionManager, segDisplaySet, headers) {\n  const utilityModule = extensionManager.getModuleEntry(\n    '@ohif/extension-cornerstone.utilityModule.common'\n  );\n\n  const { dicomLoaderService } = utilityModule.exports;\n  const segArrayBuffer = await dicomLoaderService.findDicomDataPromise(\n    segDisplaySet,\n    null,\n    headers\n  );\n\n  const dicomData = DicomMessage.readFile(segArrayBuffer);\n  const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\n  dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n\n  if (!Array.isArray(dataset.SegmentSequence)) {\n    dataset.SegmentSequence = [dataset.SegmentSequence];\n  }\n\n  const segments = _getSegments(dataset);\n  return segments;\n}\n\nfunction _segmentationExists(segDisplaySet, segmentationService) {\n  // This should be abstracted with the CornerstoneCacheService\n  return segmentationService.getSegmentation(\n    segDisplaySet.displaySetInstanceUID\n  );\n}\n\nfunction _getPixelData(dataset, segments) {\n  let frameSize = Math.ceil((dataset.Rows * dataset.Columns) / 8);\n  let nextOffset = 0;\n\n  Object.keys(segments).forEach(segmentKey => {\n    const segment = segments[segmentKey];\n    segment.numberOfFrames = segment.functionalGroups.length;\n    segment.size = segment.numberOfFrames * frameSize;\n    segment.offset = nextOffset;\n    nextOffset = segment.offset + segment.size;\n    const packedSegment = dataset.PixelData[0].slice(\n      segment.offset,\n      nextOffset\n    );\n\n    segment.pixelData = dcmjs.data.BitArray.unpack(packedSegment);\n    segment.geometry = geometryFromFunctionalGroups(\n      dataset,\n      segment.functionalGroups\n    );\n  });\n\n  return segments;\n}\n\nfunction geometryFromFunctionalGroups(dataset, perFrame) {\n  let pixelMeasures =\n    dataset.SharedFunctionalGroupsSequence.PixelMeasuresSequence;\n  let planeOrientation =\n    dataset.SharedFunctionalGroupsSequence.PlaneOrientationSequence;\n  let planePosition = perFrame[0].PlanePositionSequence; // TODO: assume sorted frames!\n\n  const geometry = {};\n\n  // NB: DICOM PixelSpacing is defined as Row then Column,\n  // unlike ImageOrientationPatient\n  let spacingBetweenSlices = pixelMeasures.SpacingBetweenSlices;\n  if (!spacingBetweenSlices) {\n    if (pixelMeasures.SliceThickness) {\n      console.log('Using SliceThickness as SpacingBetweenSlices');\n      spacingBetweenSlices = pixelMeasures.SliceThickness;\n    }\n  }\n  geometry.spacing = [\n    pixelMeasures.PixelSpacing[1],\n    pixelMeasures.PixelSpacing[0],\n    spacingBetweenSlices,\n  ].map(Number);\n\n  geometry.dimensions = [dataset.Columns, dataset.Rows, perFrame.length].map(\n    Number\n  );\n\n  let orientation = planeOrientation.ImageOrientationPatient.map(Number);\n  const columnStepToPatient = orientation.slice(0, 3);\n  const rowStepToPatient = orientation.slice(3, 6);\n  geometry.planeNormal = [];\n  vtkMath.cross(columnStepToPatient, rowStepToPatient, geometry.planeNormal);\n\n  let firstPosition = perFrame[0].PlanePositionSequence.ImagePositionPatient.map(\n    Number\n  );\n  let lastPosition = perFrame[\n    perFrame.length - 1\n  ].PlanePositionSequence.ImagePositionPatient.map(Number);\n  geometry.sliceStep = [];\n  vtkMath.subtract(lastPosition, firstPosition, geometry.sliceStep);\n  vtkMath.normalize(geometry.sliceStep);\n  geometry.direction = columnStepToPatient\n    .concat(rowStepToPatient)\n    .concat(geometry.sliceStep);\n  geometry.origin = planePosition.ImagePositionPatient.map(Number);\n\n  return geometry;\n}\n\nfunction _getSegments(dataset) {\n  const segments = {};\n\n  dataset.SegmentSequence.forEach(segment => {\n    const cielab = segment.RecommendedDisplayCIELabValue;\n    const rgba = dcmjs.data.Colors.dicomlab2RGB(cielab).map(x =>\n      Math.round(x * 255)\n    );\n\n    rgba.push(255);\n    const segmentNumber = segment.SegmentNumber;\n\n    segments[segmentNumber] = {\n      color: rgba,\n      functionalGroups: [],\n      offset: null,\n      size: null,\n      pixelData: null,\n      label: segment.SegmentLabel,\n    };\n  });\n\n  // make a list of functional groups per segment\n  dataset.PerFrameFunctionalGroupsSequence.forEach(functionalGroup => {\n    const segmentNumber =\n      functionalGroup.SegmentIdentificationSequence.ReferencedSegmentNumber;\n    segments[segmentNumber].functionalGroups.push(functionalGroup);\n  });\n\n  return _getPixelData(dataset, segments);\n}\n\nfunction getSopClassHandlerModule({ servicesManager, extensionManager }) {\n  const getDisplaySetsFromSeries = instances => {\n    return _getDisplaySetsFromSeries(\n      instances,\n      servicesManager,\n      extensionManager\n    );\n  };\n\n  return [\n    {\n      name: 'dicom-seg',\n      sopClassUids,\n      getDisplaySetsFromSeries,\n    },\n  ];\n}\n\nexport default getSopClassHandlerModule;\n","import React from 'react';\nimport { Input, Dialog } from '@ohif/ui';\n\nfunction callInputDialog(uiDialogService, label, callback) {\n  const dialogId = 'enter-segment-label';\n\n  const onSubmitHandler = ({ action, value }) => {\n    switch (action.id) {\n      case 'save':\n        callback(value.label, action.id);\n        break;\n      case 'cancel':\n        callback('', action.id);\n        break;\n    }\n    uiDialogService.dismiss({ id: dialogId });\n  };\n\n  if (uiDialogService) {\n    uiDialogService.create({\n      id: dialogId,\n      centralize: true,\n      isDraggable: false,\n      showOverlay: true,\n      content: Dialog,\n      contentProps: {\n        title: 'Segment',\n        value: { label },\n        noCloseButton: true,\n        onClose: () => uiDialogService.dismiss({ id: dialogId }),\n        actions: [\n          { id: 'cancel', text: 'Cancel', type: 'primary' },\n          { id: 'save', text: 'Confirm', type: 'secondary' },\n        ],\n        onSubmit: onSubmitHandler,\n        body: ({ value, setValue }) => {\n          return (\n            <Input\n              label=\"Enter the segment label\"\n              labelClassName=\"text-white text-[14px] leading-[1.2]\"\n              autoFocus\n              className=\"bg-black border-primary-main\"\n              type=\"text\"\n              value={value.label}\n              onChange={event => {\n                event.persist();\n                setValue(value => ({ ...value, label: event.target.value }));\n              }}\n              onKeyPress={event => {\n                if (event.key === 'Enter') {\n                  onSubmitHandler({ value, action: { id: 'save' } });\n                }\n              }}\n            />\n          );\n        },\n      },\n    });\n  }\n}\n\nexport default callInputDialog;\n","import React, { useEffect, useState, useCallback } from 'react';\nimport PropTypes from 'prop-types';\nimport { SegmentationGroupTable } from '@ohif/ui';\nimport callInputDialog from './callInputDialog';\n\nimport { useTranslation } from 'react-i18next';\n\nexport default function PanelSegmentation({\n  servicesManager,\n  commandsManager,\n}) {\n  const { segmentationService, uiDialogService } = servicesManager.services;\n\n  const { t } = useTranslation('PanelSegmentation');\n  const [selectedSegmentationId, setSelectedSegmentationId] = useState(null);\n  const [segmentationConfiguration, setSegmentationConfiguration] = useState(\n    segmentationService.getConfiguration()\n  );\n\n  const [segmentations, setSegmentations] = useState(() =>\n    segmentationService.getSegmentations()\n  );\n\n  const [isMinimized, setIsMinimized] = useState({});\n\n  const onToggleMinimizeSegmentation = useCallback(\n    id => {\n      setIsMinimized(prevState => ({\n        ...prevState,\n        [id]: !prevState[id],\n      }));\n    },\n    [setIsMinimized]\n  );\n\n  // Only expand the last segmentation added to the list and collapse the rest\n  useEffect(() => {\n    const lastSegmentationId = segmentations[segmentations.length - 1]?.id;\n    if (lastSegmentationId) {\n      setIsMinimized(prevState => ({\n        ...prevState,\n        [lastSegmentationId]: false,\n      }));\n    }\n  }, [segmentations, setIsMinimized]);\n\n  useEffect(() => {\n    // ~~ Subscription\n    const added = segmentationService.EVENTS.SEGMENTATION_ADDED;\n    const updated = segmentationService.EVENTS.SEGMENTATION_UPDATED;\n    const removed = segmentationService.EVENTS.SEGMENTATION_REMOVED;\n    const subscriptions = [];\n\n    [added, updated, removed].forEach(evt => {\n      const { unsubscribe } = segmentationService.subscribe(evt, () => {\n        const segmentations = segmentationService.getSegmentations();\n        setSegmentations(segmentations);\n        setSegmentationConfiguration(segmentationService.getConfiguration());\n      });\n      subscriptions.push(unsubscribe);\n    });\n\n    return () => {\n      subscriptions.forEach(unsub => {\n        unsub();\n      });\n    };\n  }, []);\n\n  const onSegmentationClick = (segmentationId: string) => {\n    segmentationService.setActiveSegmentationForToolGroup(segmentationId);\n  };\n\n  const onSegmentationDelete = (segmentationId: string) => {\n    segmentationService.remove(segmentationId);\n  };\n\n  const getToolGroupIds = segmentationId => {\n    const toolGroupIds = segmentationService.getToolGroupIdsWithSegmentation(\n      segmentationId\n    );\n\n    return toolGroupIds;\n  };\n\n  const onSegmentClick = (segmentationId, segmentIndex) => {\n    segmentationService.setActiveSegmentForSegmentation(\n      segmentationId,\n      segmentIndex\n    );\n\n    const toolGroupIds = getToolGroupIds(segmentationId);\n\n    toolGroupIds.forEach(toolGroupId => {\n      // const toolGroupId =\n      segmentationService.setActiveSegmentationForToolGroup(\n        segmentationId,\n        toolGroupId\n      );\n      segmentationService.jumpToSegmentCenter(\n        segmentationId,\n        segmentIndex,\n        toolGroupId\n      );\n    });\n  };\n\n  const onSegmentEdit = (segmentationId, segmentIndex) => {\n    const segmentation = segmentationService.getSegmentation(segmentationId);\n\n    const segment = segmentation.segments[segmentIndex];\n    const { label } = segment;\n\n    callInputDialog(uiDialogService, label, (label, actionId) => {\n      if (label === '') {\n        return;\n      }\n\n      segmentationService.setSegmentLabelForSegmentation(\n        segmentationId,\n        segmentIndex,\n        label\n      );\n    });\n  };\n\n  const onSegmentationEdit = segmentationId => {\n    const segmentation = segmentationService.getSegmentation(segmentationId);\n    const { label } = segmentation;\n\n    callInputDialog(uiDialogService, label, (label, actionId) => {\n      if (label === '') {\n        return;\n      }\n\n      segmentationService.addOrUpdateSegmentation(\n        {\n          id: segmentationId,\n          label,\n        },\n        false, // suppress event\n        true // notYetUpdatedAtSource\n      );\n    });\n  };\n\n  const onSegmentColorClick = (segmentationId, segmentIndex) => {\n    // Todo: Implement color picker later\n    return;\n  };\n\n  const onSegmentDelete = (segmentationId, segmentIndex) => {\n    // segmentationService.removeSegmentFromSegmentation(\n    //   segmentationId,\n    //   segmentIndex\n    // );\n    console.warn('not implemented yet');\n  };\n\n  const onToggleSegmentVisibility = (segmentationId, segmentIndex) => {\n    const segmentation = segmentationService.getSegmentation(segmentationId);\n    const segmentInfo = segmentation.segments[segmentIndex];\n    const isVisible = !segmentInfo.isVisible;\n    const toolGroupIds = getToolGroupIds(segmentationId);\n\n    // Todo: right now we apply the visibility to all tool groups\n    toolGroupIds.forEach(toolGroupId => {\n      segmentationService.setSegmentVisibility(\n        segmentationId,\n        segmentIndex,\n        isVisible,\n        toolGroupId\n      );\n    });\n  };\n\n  const onToggleSegmentationVisibility = segmentationId => {\n    segmentationService.toggleSegmentationVisibility(segmentationId);\n  };\n\n  const _setSegmentationConfiguration = useCallback(\n    (segmentationId, key, value) => {\n      segmentationService.setConfiguration({\n        segmentationId,\n        [key]: value,\n      });\n    },\n    [segmentationService]\n  );\n\n  return (\n    <div className=\"flex flex-col flex-auto min-h-0 justify-between mt-1\">\n      {/* show segmentation table */}\n      {segmentations?.length ? (\n        <SegmentationGroupTable\n          title={t('Segmentations')}\n          showAddSegmentation={false}\n          segmentations={segmentations}\n          isMinimized={isMinimized}\n          activeSegmentationId={selectedSegmentationId || ''}\n          onSegmentationClick={onSegmentationClick}\n          onSegmentationDelete={onSegmentationDelete}\n          onSegmentationEdit={onSegmentationEdit}\n          onSegmentClick={onSegmentClick}\n          onSegmentEdit={onSegmentEdit}\n          onSegmentColorClick={onSegmentColorClick}\n          onSegmentDelete={onSegmentDelete}\n          onToggleSegmentVisibility={onToggleSegmentVisibility}\n          onToggleSegmentationVisibility={onToggleSegmentationVisibility}\n          onToggleMinimizeSegmentation={onToggleMinimizeSegmentation}\n          segmentationConfig={{ initialConfig: segmentationConfiguration }}\n          setRenderOutline={value =>\n            _setSegmentationConfiguration(\n              selectedSegmentationId,\n              'renderOutline',\n              value\n            )\n          }\n          setOutlineOpacityActive={value =>\n            _setSegmentationConfiguration(\n              selectedSegmentationId,\n              'outlineOpacity',\n              value\n            )\n          }\n          setRenderFill={value =>\n            _setSegmentationConfiguration(\n              selectedSegmentationId,\n              'renderFill',\n              value\n            )\n          }\n          setRenderInactiveSegmentations={value =>\n            _setSegmentationConfiguration(\n              selectedSegmentationId,\n              'renderInactiveSegmentations',\n              value\n            )\n          }\n          setOutlineWidthActive={value =>\n            _setSegmentationConfiguration(\n              selectedSegmentationId,\n              'outlineWidthActive',\n              value\n            )\n          }\n          setFillAlpha={value =>\n            _setSegmentationConfiguration(\n              selectedSegmentationId,\n              'fillAlpha',\n              value\n            )\n          }\n          setFillAlphaInactive={value =>\n            _setSegmentationConfiguration(\n              selectedSegmentationId,\n              'fillAlphaInactive',\n              value\n            )\n          }\n        />\n      ) : null}\n    </div>\n  );\n}\n\nPanelSegmentation.propTypes = {\n  commandsManager: PropTypes.shape({\n    runCommand: PropTypes.func.isRequired,\n  }),\n  servicesManager: PropTypes.shape({\n    services: PropTypes.shape({\n      segmentationService: PropTypes.shape({\n        getSegmentation: PropTypes.func.isRequired,\n        getSegmentations: PropTypes.func.isRequired,\n        toggleSegmentationVisibility: PropTypes.func.isRequired,\n        subscribe: PropTypes.func.isRequired,\n        EVENTS: PropTypes.object.isRequired,\n      }).isRequired,\n    }).isRequired,\n  }).isRequired,\n};\n","import { Types } from '@ohif/core';\n\nconst segProtocol: Types.HangingProtocol.Protocol = {\n  id: '@ohif/seg',\n  // Don't store this hanging protocol as it applies to the currently active\n  // display set by default\n  // cacheId: null,\n  hasUpdatedPriorsInformation: false,\n  name: 'Segmentations',\n  // Just apply this one when specifically listed\n  protocolMatchingRules: [],\n  toolGroupIds: ['default'],\n  // -1 would be used to indicate active only, whereas other values are\n  // the number of required priors referenced - so 0 means active with\n  // 0 or more priors.\n  numberOfPriorsReferenced: 0,\n  // Default viewport is used to define the viewport when\n  // additional viewports are added using the layout tool\n  defaultViewport: {\n    viewportOptions: {\n      viewportType: 'stack',\n      toolGroupId: 'default',\n      allowUnmatchedView: true,\n    },\n    displaySets: [\n      {\n        id: 'segDisplaySetId',\n        matchedDisplaySetsIndex: -1,\n      },\n    ],\n  },\n  displaySetSelectors: {\n    segDisplaySetId: {\n      seriesMatchingRules: [\n        {\n          attribute: 'Modality',\n          constraint: {\n            equals: 'SEG',\n          },\n        },\n      ],\n    },\n  },\n  stages: [\n    {\n      name: 'Segmentations',\n      viewportStructure: {\n        layoutType: 'grid',\n        properties: {\n          rows: 1,\n          columns: 1,\n        },\n      },\n      viewports: [\n        {\n          viewportOptions: { allowUnmatchedView: true },\n          displaySets: [\n            {\n              id: 'segDisplaySetId',\n            },\n          ],\n        },\n      ],\n    },\n  ],\n};\n\nfunction getHangingProtocolModule() {\n  return [\n    {\n      name: segProtocol.id,\n      protocol: segProtocol,\n    },\n  ];\n}\n\nexport default getHangingProtocolModule;\nexport { segProtocol };\n","import { id } from './id';\nimport React from 'react';\n\nimport { Types } from '@ohif/core';\n\nimport getSopClassHandlerModule from './getSopClassHandlerModule';\nimport PanelSegmentation from './panels/PanelSegmentation';\nimport getHangingProtocolModule from './getHangingProtocolModule';\n\nconst Component = React.lazy(() => {\n  return import(\n    /* webpackPrefetch: true */ './viewports/OHIFCornerstoneSEGViewport'\n  );\n});\n\nconst OHIFCornerstoneSEGViewport = props => {\n  return (\n    <React.Suspense fallback={<div>Loading...</div>}>\n      <Component {...props} />\n    </React.Suspense>\n  );\n};\n\n/**\n * You can remove any of the following modules if you don't need them.\n */\nconst extension = {\n  /**\n   * Only required property. Should be a unique value across all extensions.\n   * You ID can be anything you want, but it should be unique.\n   */\n  id,\n\n  /**\n   * PanelModule should provide a list of panels that will be available in OHIF\n   * for Modes to consume and render. Each panel is defined by a {name,\n   * iconName, iconLabel, label, component} object. Example of a panel module\n   * is the StudyBrowserPanel that is provided by the default extension in OHIF.\n   */\n  getPanelModule: ({\n    servicesManager,\n    commandsManager,\n    extensionManager,\n  }): Types.Panel[] => {\n    const wrappedPanelSegmentation = () => {\n      return (\n        <PanelSegmentation\n          commandsManager={commandsManager}\n          servicesManager={servicesManager}\n          extensionManager={extensionManager}\n        />\n      );\n    };\n\n    return [\n      {\n        name: 'panelSegmentation',\n        iconName: 'tab-segmentation',\n        iconLabel: 'Segmentation',\n        label: 'Segmentation',\n        component: wrappedPanelSegmentation,\n      },\n    ];\n  },\n\n  getViewportModule({ servicesManager, extensionManager }) {\n    const ExtendedOHIFCornerstoneSEGViewport = props => {\n      return (\n        <OHIFCornerstoneSEGViewport\n          servicesManager={servicesManager}\n          extensionManager={extensionManager}\n          {...props}\n        />\n      );\n    };\n\n    return [\n      { name: 'dicom-seg', component: ExtendedOHIFCornerstoneSEGViewport },\n    ];\n  },\n  /**\n   * SopClassHandlerModule should provide a list of sop class handlers that will be\n   * available in OHIF for Modes to consume and use to create displaySets from Series.\n   * Each sop class handler is defined by a { name, sopClassUids, getDisplaySetsFromSeries}.\n   * Examples include the default sop class handler provided by the default extension\n   */\n  getSopClassHandlerModule,\n  getHangingProtocolModule,\n};\n\nexport default extension;"],"names":["id","packageJson","SOPClassHandlerId","DicomMessage","DicomMetaDictionary","dcmjs","sopClassUids","loadPromises","_getDisplaySetsFromSeries","instances","servicesManager","extensionManager","instance","StudyInstanceUID","SeriesInstanceUID","SOPInstanceUID","SeriesDescription","SeriesNumber","SeriesDate","SOPClassUID","wadoRoot","wadoUri","wadoUriRoot","displaySet","Modality","loading","isReconstructable","displaySetInstanceUID","utils","guid","referencedImages","referencedSeriesInstanceUID","referencedDisplaySetInstanceUID","isDerivedDisplaySet","isLoaded","isHydrated","segments","isOverlayDisplaySet","referencedSeriesSequence","ReferencedSeriesSequence","Error","referencedSeries","ReferencedInstanceSequence","getReferenceDisplaySet","displaySetService","services","referencedDisplaySets","getDisplaySetsForSeries","length","referencedDisplaySet","referencedVolumeURI","referencedVolumeId","load","async","headers","_ref","segDisplaySet","segmentationService","getSegmentation","_segmentationExists","Promise","resolve","reject","Object","keys","utilityModule","getModuleEntry","dicomLoaderService","exports","segArrayBuffer","findDicomDataPromise","dicomData","readFile","dataset","naturalizeDataset","dict","_meta","namifyDataset","meta","Array","isArray","SegmentSequence","forEach","segment","cielab","RecommendedDisplayCIELabValue","rgba","Colors","dicomlab2RGB","map","x","Math","round","push","segmentNumber","SegmentNumber","color","functionalGroups","offset","size","pixelData","label","SegmentLabel","PerFrameFunctionalGroupsSequence","functionalGroup","SegmentIdentificationSequence","ReferencedSegmentNumber","frameSize","ceil","Rows","Columns","nextOffset","segmentKey","numberOfFrames","packedSegment","PixelData","slice","BitArray","unpack","geometry","perFrame","pixelMeasures","SharedFunctionalGroupsSequence","PixelMeasuresSequence","planeOrientation","PlaneOrientationSequence","planePosition","PlanePositionSequence","spacingBetweenSlices","SpacingBetweenSlices","SliceThickness","console","log","spacing","PixelSpacing","Number","dimensions","orientation","ImageOrientationPatient","columnStepToPatient","rowStepToPatient","planeNormal","vtkMath","firstPosition","ImagePositionPatient","lastPosition","sliceStep","direction","concat","origin","geometryFromFunctionalGroups","_getPixelData","_getSegments","_loadSegments","suppressEvents","createSegmentationForSEGDisplaySet","then","catch","error","_load","_ref2","name","getDisplaySetsFromSeries","uiDialogService","callback","dialogId","onSubmitHandler","action","value","dismiss","create","centralize","isDraggable","showOverlay","content","Dialog","contentProps","title","noCloseButton","onClose","actions","text","type","onSubmit","body","setValue","React","Input","labelClassName","autoFocus","className","onChange","event","persist","target","onKeyPress","key","PanelSegmentation","commandsManager","t","useTranslation","selectedSegmentationId","setSelectedSegmentationId","useState","segmentationConfiguration","setSegmentationConfiguration","getConfiguration","segmentations","setSegmentations","getSegmentations","isMinimized","setIsMinimized","onToggleMinimizeSegmentation","useCallback","prevState","useEffect","lastSegmentationId","added","EVENTS","SEGMENTATION_ADDED","updated","SEGMENTATION_UPDATED","removed","SEGMENTATION_REMOVED","subscriptions","evt","unsubscribe","subscribe","unsub","getToolGroupIds","segmentationId","getToolGroupIdsWithSegmentation","_setSegmentationConfiguration","setConfiguration","SegmentationGroupTable","showAddSegmentation","activeSegmentationId","onSegmentationClick","setActiveSegmentationForToolGroup","onSegmentationDelete","remove","onSegmentationEdit","segmentation","callInputDialog","actionId","addOrUpdateSegmentation","onSegmentClick","segmentIndex","setActiveSegmentForSegmentation","toolGroupId","jumpToSegmentCenter","onSegmentEdit","setSegmentLabelForSegmentation","onSegmentColorClick","onSegmentDelete","warn","onToggleSegmentVisibility","isVisible","setSegmentVisibility","onToggleSegmentationVisibility","toggleSegmentationVisibility","segmentationConfig","initialConfig","setRenderOutline","setOutlineOpacityActive","setRenderFill","setRenderInactiveSegmentations","setOutlineWidthActive","setFillAlpha","setFillAlphaInactive","propTypes","PropTypes","runCommand","isRequired","segProtocol","hasUpdatedPriorsInformation","protocolMatchingRules","toolGroupIds","numberOfPriorsReferenced","defaultViewport","viewportOptions","viewportType","allowUnmatchedView","displaySets","matchedDisplaySetsIndex","displaySetSelectors","segDisplaySetId","seriesMatchingRules","attribute","constraint","equals","stages","viewportStructure","layoutType","properties","rows","columns","viewports","protocol","Component","OHIFCornerstoneSEGViewport","props","fallback","getPanelModule","iconName","iconLabel","component","wrappedPanelSegmentation","getViewportModule","_extends","getSopClassHandlerModule","getHangingProtocolModule"],"sourceRoot":""}