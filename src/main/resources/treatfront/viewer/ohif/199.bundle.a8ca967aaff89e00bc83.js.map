{"version":3,"file":"199.bundle.a8ca967aaff89e00bc83.js","mappings":"oIAEMA,E,4DAAKC,GAELC,EAAqB,GAAEF,mC,qCCH7B,MAAM,aAAEG,EAAY,oBAAEC,GAAwBC,EAAAA,QAAAA,KACxCC,EAAeD,EAAAA,QAAAA,KAAWE,OAAOD,aA2GxBE,eAAeC,EAC5BC,EACAC,EACAC,EACAC,GAEA,MAAMC,EAAgBJ,EAAiBK,eACrC,oDAEIC,EAAaN,EAAiBO,sBAAsB,IACpD,YAAEC,GAAgBF,EAAWG,eAAiB,CAAC,GAE/C,mBAAEC,GAAuBN,EAAcO,QACvCC,EAwHR,SAAqDV,GACnD,OAAOA,EAAqBW,OAAOC,KAAIC,IAC9B,CACLC,QAASD,EAAMC,QACfC,eAAgBF,EAAMG,kBAG5B,CA/HqCC,CACjCjB,GAKFD,EAAmBmB,UAAW,EAC9B,IAAIC,EAAWpB,EAAmBoB,SAElC,GAAKb,GAAgBA,EAAYc,cA/HnCxB,eAAuCuB,EAAUE,GAC/C,IAAKF,IAAaA,EAASG,mBACzB,OAAOC,QAAQC,OAAO,iDAGxB,MAAMC,EAAc,IAAIC,IAExB,IAAK,MAAMC,KAAcR,EAASG,mBAAoB,CACpD,MAAMM,EAAsBD,EAAWE,oBACvC,GAAKF,GAAeA,EAAWG,gBAK/B,IAAK,MAAMC,KAAWJ,EAAWG,gBAAiB,CAChD,IAAKC,IAAYA,EAAQC,YACvB,OAAOT,QAAQC,OAAO,kCAGxB,MAAMS,EAAcF,EAAQC,YAE5B,GAAIE,MAAMC,QAAQF,GAChBR,EAAYW,IAAIR,GACZH,EACGY,IAAIT,GACJU,KAAKf,QAAQgB,QAAQN,IACxBR,EAAYe,IAAIZ,EAAqB,CACnCL,QAAQgB,QAAQN,SAEjB,KAAIA,IAAeA,EAAYQ,YAwBpC,OAAOlB,QAAQC,OAAQ,wBAAuBS,KAxBG,CACjD,MAAM3B,EAAc2B,EAAYQ,YAEhC,IACGpB,IACAA,EAAWqB,WACXrB,EAAWqB,SAASpC,YAErB,OAAOiB,QAAQC,OACb,kDAIJ,MAAMmB,EAAkBtB,EAAWqB,SAASpC,YAAY,CACtDmC,YAAanC,EACbsC,iBAAkBzB,EAASyB,iBAC3BC,kBAAmB1B,EAAS0B,kBAC5B7B,eAAgBG,EAASH,iBAG3BS,EAAYW,IAAIR,GACZH,EAAYY,IAAIT,GAAqBU,KAAKK,GAC1ClB,EAAYe,IAAIZ,EAAqB,CAACe,GAC5C,CAEA,CACF,MA7CElB,EAAYe,IAAIZ,EAAqB,CAACL,QAAQgB,QAAQ,KA8C1D,CAEA,MAAMO,EAAsB,IAAIpB,IAChC,IAAK,MAAOqB,EAAKC,KAAiBvB,EAAYwB,UAC5CH,EAAoBN,IAAIO,QAAWxB,QAAQ2B,WAAWF,IAGxD7B,EAASG,mBAAmB6B,SAAQxB,IAClC,IACE,MAAMC,EAAsBD,EAAWE,oBACjCuB,EAAmBN,EAAoBT,IAAIT,GAE7CD,EAAWG,iBACbH,EAAWG,gBAAgBqB,SAAQ,CAACpB,EAASsB,KAC3C,MAAMC,EAAUF,EAAiBC,GACjC,GAAuB,cAAnBC,EAAQC,OACV,GACErB,MAAMC,QAAQmB,EAAQE,QACtBF,EAAQE,MAAMC,MAAMC,OAAOC,UAG3B5B,EAAQC,YAAcsB,EAAQE,UACzB,CAEL,MAAMI,EAAa,IAAIC,WAAWP,EAAQE,OAEpCM,GADc,IAAIC,aACWC,OAAOJ,GAEd,iBAAnBE,GACPA,EAAeG,SAAS,MAExBlC,EAAQC,YAAc8B,EACnBI,MAAM,MACNtD,IAAIuD,YAEPpC,EAAQC,YAAc,EAE1B,MAEAoC,QAAQC,MAAMf,EAAQgB,OACxB,GAGN,CAAE,MAAOD,GACPD,QAAQC,MAAMA,EAChB,IAEJ,CAsCUE,CAAwBpD,EAAUf,OAdA,CACxC,MAAMoE,QAAuBhE,EAAmBiE,qBAC9C1E,EACA,KACAE,GAGIyE,EAAYnF,EAAaoF,SAASH,GAClCI,EAAkBpF,EAAoBqF,kBAC1CH,EAAUI,MAEZF,EAAgBG,MAAQvF,EAAoBwF,cAAcN,EAAUO,MACpE9D,EAAWyD,CACb,CAIA,MAAM,wBACJM,EAAuB,mBACvB5D,EAAkB,0BAClB6D,GACEhE,EAGEiE,EAAe,CACnBC,kBAAmBlE,EAASkE,kBAC5BxC,kBAAmB1B,EAAS0B,kBAC5ByC,YAAa,GACbC,SAAS,GAGX,IAAK,IAAIC,EAAI,EAAGA,EAAIlE,EAAmBmE,OAAQD,IAAK,CAClD,MAAM7D,EAAaL,EAAmBkE,IAChC,gBAAE1D,GAAoBH,EAE5B,IAAKG,EACH,SAGF,MAAM4D,GAAc,EAEdC,GA4JQC,EA5JwB9D,EA6JjCI,MAAMC,QAAQyD,GAAcA,EAAa,CAACA,IA3JzCC,EAAgB,GACtB,IAAK,IAAIC,EAAI,EAAGA,EAAIH,EAAqBF,OAAQK,IAAK,CACpD,MAAM,qBACJC,EAAoB,YACpB/D,EAAW,sBACXgE,EAAqB,qBACrBC,GACEN,EAAqBG,GAEnB/E,EAAiBgF,EAAqBG,yBAG5C,IAFgBC,EAAYzF,EAA4BK,GAGtD,SAEF,IAAI2E,GAAc,EAElB,MAAMU,EAAS,GACf,IAAK,IAAIC,EAAI,EAAGA,EAA4B,EAAxBL,EAA2BK,GAAK,EAClDD,EAAO9D,KAAK,CACVgE,EAAGtE,EAAYqE,GACfE,EAAGvE,EAAYqE,EAAI,GACnBG,EAAGxE,EAAYqE,EAAI,KAIvB,OAAQJ,GACN,IAAK,gBACL,IAAK,cACL,IAAK,QACHP,GAAc,EAEd,MACF,QACE,SAGJG,EAAcvD,KAAK,CACjBmE,eAAgBT,EAChBI,SACAM,KAAMT,EACNP,eAEJ,CAEAiB,EACEvB,EACAF,EACAC,EACAxD,EACAkE,EACAH,EAEJ,CAqGF,IAAkBE,EApGhB,OAAOR,CACT,CAEA,MAAMe,EAAcA,CAACzF,EAA4BK,KAC/C,MAAM6F,EAAkClG,EAA2BmG,MACjED,GACEA,EAAgC7F,iBAAmBA,IAGvD,OAAO6F,EACHA,EAAgC9F,QAChC,IAAI,EAYV,SAAS6F,EACPvB,EACAF,EACAC,EACAxD,EACAkE,EACAH,GAEA,MAAMoB,EAAkB5B,EAAwB2B,MAC9CE,GACEA,EAAgBC,YAAcrF,EAAWE,sBAGvCoF,EAAiB,CACrBD,UAAWF,EAAgBE,UAC3BE,QAASJ,EAAgBI,QACzBC,uBAAwBL,EAAgBK,uBACxCC,eAAgBN,EAAgBM,eAChC1B,cACAG,gBACAN,SAAS,IAiBb,SAAiC5D,EAAYsF,GAC3C,IAAI,gBAAEI,EAAe,8BAAEC,GAAkC3F,GAEpD0F,GAAmBC,IAEtBD,EAAkB3H,EAAa4H,IAG7BD,IACFJ,EAAeM,WAAa,IAAIF,GAEpC,CAzBEG,CAAwB7F,EAAYsF,GAEhC9B,GAyBN,SACE8B,EACA9B,EACA6B,GAEA,MAAMS,EAAoBtC,EAA0B0B,MAClDY,GAAqBA,EAAkB5F,sBAAwBmF,IAGjE,GAAIS,EAAmB,CAErB,MAAM,kBACJC,EAAiB,0BACjBC,EAAyB,qBACzBC,EAAoB,eACpBC,GACEJ,EAEJR,EAAeQ,kBAAoB,CACjCC,oBACAC,4BACAC,uBACAC,iBAEJ,CACF,CAhDIC,CACEb,EACA9B,EACAxD,EAAWE,qBAIfuD,EAAaE,YAAYhD,KAAK2E,EAChC,CCzRA,MAAMc,EAAe,CAAC,iCAEtB,IAAIC,EAAe,CAAC,EAEpB,SAASC,EACPC,EACAC,EACArI,GAEA,MAAMqB,EAAW+G,EAAU,IAErB,iBACJtF,EAAgB,kBAChBC,EAAiB,eACjB7B,EAAc,kBACdoH,EAAiB,aACjBC,EAAY,WACZC,EAAU,YACVC,EAAW,SACXC,EAAQ,QACRC,EAAO,YACPC,GACEvH,EAEEwH,EAAa,CACjBC,SAAU,WACVC,SAAS,EACTC,mBAAmB,EACnBC,sBAAuBC,EAAAA,MAAMC,OAC7Bb,oBACAC,eACAC,aACAtH,iBACA6B,oBACAD,mBACAtD,kBAAiB,EACjBiJ,cACAW,iBAAkB,KAClBC,4BAA6B,KAC7BC,gCAAiC,KACjCC,qBAAqB,EACrBnI,UAAU,EACVoI,YAAY,EACZlE,aAAc,KACd2C,eACA5G,WACAqH,WACAE,cACAD,UACAc,qBAAqB,GAGvB,IAAIC,EAA2BrI,EAASsI,yBAWxC,GATEtI,EAASuI,qCACRvI,EAASsI,2BAEVtI,EAASsI,yBAmFb,SACEC,GAEA,MAAMD,EAA2B,GA6BjC,OA3BAC,EAAmCvG,SAAQwG,IACzC,MAAM,0BAAEC,GAA8BD,EAEtCC,EAA0BzG,SAAQ0G,IAChC,MAAM,2BAAEC,GAA+BD,EAEvCC,EAA2B3G,SAAQ4G,IACjC,MAAMC,EAA6B,IAC7B,qBAAEjE,EAAoB,kBAAElD,GAAsBkH,EAEpDhE,EAAqB5C,SAAQ8G,IAC3BD,EAA2B1H,KAAK,CAC9B4D,yBAA0B+D,EAAa/D,yBACvCgE,sBAAuBD,EAAaC,uBACpC,IAGJ,MAAMC,EAAmB,CACvBtH,oBACAmH,8BAGFP,EAAyBnH,KAAK6H,EAAiB,GAC/C,GACF,IAGGV,CACT,CApHwCW,CAClCjJ,EAASuI,oCAEXF,EAA2BrI,EAASsI,2BAGjCD,EACH,MAAM,IAAIa,MAAM,wDAGlB,MAAMF,EAAmBX,EAAyB,GA2BlD,OAzBAb,EAAWO,iBACT/H,EAASsI,yBAAyBO,2BACpCrB,EAAWQ,4BAA8BgB,EAAiBtH,kBAE1D8F,EAAW2B,uBAAyB,KAClC,MAAM,kBAAEC,GAAsBpC,EAAgBqC,SACxCC,EAAwBF,EAAkBG,wBAC9C/B,EAAWQ,6BAGb,IAAKsB,GAA0D,IAAjCA,EAAsBhF,OAClD,MAAM,IAAI4E,MAAM,+CAGlB,MAAMrK,EAAuByK,EAAsB,GAKnD,OAHA9B,EAAWS,gCACTpJ,EAAqB+I,sBAEhB/I,CAAoB,EAG7B2I,EAAWgC,KAAOC,IAAA,IAAC,QAAE3K,GAAS2K,EAAA,OAMhC,SAAeC,EAAc1C,EAAiBrI,EAAkBG,GAC9D,MAAM,eAAEe,GAAmB6J,GACrB,oBAAEC,GAAwB3C,EAAgBqC,UAE7CK,EAAahC,SAAWgC,EAAa3J,WACtC8G,EAAahH,GADb,EAoCF,OA7BA6J,EAAahC,SAAU,EAIvBb,EAAahH,GAAkB,IAAIO,SAAQ3B,MAAO2C,EAASf,KACzD,IAAKqJ,EAAazF,aAAc,CAC9B,MAAMA,QAAqBvF,EACzBC,EACA+K,EACAA,EAAaP,yBACbrK,GAGF4K,EAAazF,aAAeA,CAC9B,CAEA,MAAM2F,GAAiB,EACvBD,EACGE,kCAAkCH,EAAc,KAAME,GACtDE,MAAK,KACJJ,EAAahC,SAAU,EACvBtG,GAAS,IAEV2I,OAAM7G,IACLwG,EAAahC,SAAU,EACvBrH,EAAO6C,EAAM,GACb,IAGC2D,EAAahH,EACtB,CA9CImK,CAAMxC,EAAYR,EAAiBrI,EAAkBG,EAAQ,EAExD,CAAC0I,EACV,CA0GA,QAhBA,SAAiCyC,GAAwC,IAAvC,gBAAEjD,EAAe,iBAAErI,GAAkBsL,EACrE,MAAO,CACL,CACEC,KAAM,WACNtD,eACAuD,yBAA0BpD,GACjBD,EACLC,EACAC,EACArI,IAKV,E,oOCvMA,MAAMyL,EAAYC,EAAAA,MAAW,IACpB,iCAKHC,EAA4BC,GAE9BF,EAAAA,cAACA,EAAAA,SAAc,CAACG,SAAUH,EAAAA,cAAA,WAAK,eAC7BA,EAAAA,cAACD,EAAcG,IA8CrB,EAtC8C,CAK5CtM,GAAE,EAQFwM,kBAAiBhB,GAGoB,IAHnB,gBAChBzC,EAAe,iBACfrI,GACiC8K,EAWjC,MAAO,CAAC,CAAES,KAAM,WAAYQ,UAVcH,GAEtCF,EAAAA,cAACC,EAAyBK,EAAA,CACxB3D,gBAAiBA,EACjBrI,iBAAkBA,GACd4L,KAMZ,EAOAK,yBAAwBA,E","sources":["webpack:///../../../extensions/cornerstone-dicom-rt/src/id.js","webpack:///../../../extensions/cornerstone-dicom-rt/src/loadRTStruct.js","webpack:///../../../extensions/cornerstone-dicom-rt/src/getSopClassHandlerModule.js","webpack:///../../../extensions/cornerstone-dicom-rt/src/index.tsx"],"sourcesContent":["import packageJson from '../package.json';\n\nconst id = packageJson.name;\nconst SOPClassHandlerName = 'dicom-rt';\nconst SOPClassHandlerId = `${id}.sopClassHandlerModule.${SOPClassHandlerName}`;\n\nexport { id, SOPClassHandlerId, SOPClassHandlerName };\n","import dcmjs from 'dcmjs';\nconst { DicomMessage, DicomMetaDictionary } = dcmjs.data;\nconst dicomlab2RGB = dcmjs.data.Colors.dicomlab2RGB;\n\nasync function checkAndLoadContourData(instance, datasource) {\n  if (!instance || !instance.ROIContourSequence) {\n    return Promise.reject('Invalid instance object or ROIContourSequence');\n  }\n\n  const promisesMap = new Map();\n\n  for (const ROIContour of instance.ROIContourSequence) {\n    const referencedROINumber = ROIContour.ReferencedROINumber;\n    if (!ROIContour || !ROIContour.ContourSequence) {\n      promisesMap.set(referencedROINumber, [Promise.resolve([])]);\n      continue;\n    }\n\n    for (const Contour of ROIContour.ContourSequence) {\n      if (!Contour || !Contour.ContourData) {\n        return Promise.reject('Invalid Contour or ContourData');\n      }\n\n      const contourData = Contour.ContourData;\n\n      if (Array.isArray(contourData)) {\n        promisesMap.has(referencedROINumber)\n          ? promisesMap\n              .get(referencedROINumber)\n              .push(Promise.resolve(contourData))\n          : promisesMap.set(referencedROINumber, [\n              Promise.resolve(contourData),\n            ]);\n      } else if (contourData && contourData.BulkDataURI) {\n        const bulkDataURI = contourData.BulkDataURI;\n\n        if (\n          !datasource ||\n          !datasource.retrieve ||\n          !datasource.retrieve.bulkDataURI\n        ) {\n          return Promise.reject(\n            'Invalid datasource object or retrieve function'\n          );\n        }\n\n        const bulkDataPromise = datasource.retrieve.bulkDataURI({\n          BulkDataURI: bulkDataURI,\n          StudyInstanceUID: instance.StudyInstanceUID,\n          SeriesInstanceUID: instance.SeriesInstanceUID,\n          SOPInstanceUID: instance.SOPInstanceUID,\n        });\n\n        promisesMap.has(referencedROINumber)\n          ? promisesMap.get(referencedROINumber).push(bulkDataPromise)\n          : promisesMap.set(referencedROINumber, [bulkDataPromise]);\n      } else {\n        return Promise.reject(`Invalid ContourData: ${contourData}`);\n      }\n    }\n  }\n\n  const resolvedPromisesMap = new Map();\n  for (const [key, promiseArray] of promisesMap.entries()) {\n    resolvedPromisesMap.set(key, await Promise.allSettled(promiseArray));\n  }\n\n  instance.ROIContourSequence.forEach(ROIContour => {\n    try {\n      const referencedROINumber = ROIContour.ReferencedROINumber;\n      const resolvedPromises = resolvedPromisesMap.get(referencedROINumber);\n\n      if (ROIContour.ContourSequence) {\n        ROIContour.ContourSequence.forEach((Contour, index) => {\n          const promise = resolvedPromises[index];\n          if (promise.status === 'fulfilled') {\n            if (\n              Array.isArray(promise.value) &&\n              promise.value.every(Number.isFinite)\n            ) {\n              // If promise.value is already an array of numbers, use it directly\n              Contour.ContourData = promise.value;\n            } else {\n              // If the resolved promise value is a byte array (Blob), it needs to be decoded\n              const uint8Array = new Uint8Array(promise.value);\n              const textDecoder = new TextDecoder();\n              const dataUint8Array = textDecoder.decode(uint8Array);\n              if (\n                typeof dataUint8Array === 'string' &&\n                dataUint8Array.includes('\\\\')\n              ) {\n                Contour.ContourData = dataUint8Array\n                  .split('\\\\')\n                  .map(parseFloat);\n              } else {\n                Contour.ContourData = [];\n              }\n            }\n          } else {\n            console.error(promise.reason);\n          }\n        });\n      }\n    } catch (error) {\n      console.error(error);\n    }\n  });\n}\n\nexport default async function loadRTStruct(\n  extensionManager,\n  rtStructDisplaySet,\n  referencedDisplaySet,\n  headers\n) {\n  const utilityModule = extensionManager.getModuleEntry(\n    '@ohif/extension-cornerstone.utilityModule.common'\n  );\n  const dataSource = extensionManager.getActiveDataSource()[0];\n  const { bulkDataURI } = dataSource.getConfig?.() || {};\n\n  const { dicomLoaderService } = utilityModule.exports;\n  const imageIdSopInstanceUidPairs = _getImageIdSopInstanceUidPairsForDisplaySet(\n    referencedDisplaySet\n  );\n\n  // Set here is loading is asynchronous.\n  // If this function throws its set back to false.\n  rtStructDisplaySet.isLoaded = true;\n  let instance = rtStructDisplaySet.instance;\n\n  if (!bulkDataURI || !bulkDataURI.enabled) {\n    const segArrayBuffer = await dicomLoaderService.findDicomDataPromise(\n      rtStructDisplaySet,\n      null,\n      headers\n    );\n\n    const dicomData = DicomMessage.readFile(segArrayBuffer);\n    const rtStructDataset = DicomMetaDictionary.naturalizeDataset(\n      dicomData.dict\n    );\n    rtStructDataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n    instance = rtStructDataset;\n  } else {\n    await checkAndLoadContourData(instance, dataSource);\n  }\n\n  const {\n    StructureSetROISequence,\n    ROIContourSequence,\n    RTROIObservationsSequence,\n  } = instance;\n\n  // Define our structure set entry and add it to the rtstruct module state.\n  const structureSet = {\n    StructureSetLabel: instance.StructureSetLabel,\n    SeriesInstanceUID: instance.SeriesInstanceUID,\n    ROIContours: [],\n    visible: true,\n  };\n\n  for (let i = 0; i < ROIContourSequence.length; i++) {\n    const ROIContour = ROIContourSequence[i];\n    const { ContourSequence } = ROIContour;\n\n    if (!ContourSequence) {\n      continue;\n    }\n\n    const isSupported = false;\n\n    const ContourSequenceArray = _toArray(ContourSequence);\n\n    const contourPoints = [];\n    for (let c = 0; c < ContourSequenceArray.length; c++) {\n      const {\n        ContourImageSequence,\n        ContourData,\n        NumberOfContourPoints,\n        ContourGeometricType,\n      } = ContourSequenceArray[c];\n\n      const sopInstanceUID = ContourImageSequence.ReferencedSOPInstanceUID;\n      const imageId = _getImageId(imageIdSopInstanceUidPairs, sopInstanceUID);\n\n      if (!imageId) {\n        continue;\n      }\n      let isSupported = false;\n\n      const points = [];\n      for (let p = 0; p < NumberOfContourPoints * 3; p += 3) {\n        points.push({\n          x: ContourData[p],\n          y: ContourData[p + 1],\n          z: ContourData[p + 2],\n        });\n      }\n\n      switch (ContourGeometricType) {\n        case 'CLOSED_PLANAR':\n        case 'OPEN_PLANAR':\n        case 'POINT':\n          isSupported = true;\n\n          break;\n        default:\n          continue;\n      }\n\n      contourPoints.push({\n        numberOfPoints: NumberOfContourPoints,\n        points,\n        type: ContourGeometricType,\n        isSupported,\n      });\n    }\n\n    _setROIContourMetadata(\n      structureSet,\n      StructureSetROISequence,\n      RTROIObservationsSequence,\n      ROIContour,\n      contourPoints,\n      isSupported\n    );\n  }\n  return structureSet;\n}\n\nconst _getImageId = (imageIdSopInstanceUidPairs, sopInstanceUID) => {\n  const imageIdSopInstanceUidPairsEntry = imageIdSopInstanceUidPairs.find(\n    imageIdSopInstanceUidPairsEntry =>\n      imageIdSopInstanceUidPairsEntry.sopInstanceUID === sopInstanceUID\n  );\n\n  return imageIdSopInstanceUidPairsEntry\n    ? imageIdSopInstanceUidPairsEntry.imageId\n    : null;\n};\n\nfunction _getImageIdSopInstanceUidPairsForDisplaySet(referencedDisplaySet) {\n  return referencedDisplaySet.images.map(image => {\n    return {\n      imageId: image.imageId,\n      sopInstanceUID: image.SOPInstanceUID,\n    };\n  });\n}\n\nfunction _setROIContourMetadata(\n  structureSet,\n  StructureSetROISequence,\n  RTROIObservationsSequence,\n  ROIContour,\n  contourPoints,\n  isSupported\n) {\n  const StructureSetROI = StructureSetROISequence.find(\n    structureSetROI =>\n      structureSetROI.ROINumber === ROIContour.ReferencedROINumber\n  );\n\n  const ROIContourData = {\n    ROINumber: StructureSetROI.ROINumber,\n    ROIName: StructureSetROI.ROIName,\n    ROIGenerationAlgorithm: StructureSetROI.ROIGenerationAlgorithm,\n    ROIDescription: StructureSetROI.ROIDescription,\n    isSupported,\n    contourPoints,\n    visible: true,\n  };\n\n  _setROIContourDataColor(ROIContour, ROIContourData);\n\n  if (RTROIObservationsSequence) {\n    // If present, add additional RTROIObservations metadata.\n    _setROIContourRTROIObservations(\n      ROIContourData,\n      RTROIObservationsSequence,\n      ROIContour.ReferencedROINumber\n    );\n  }\n\n  structureSet.ROIContours.push(ROIContourData);\n}\n\nfunction _setROIContourDataColor(ROIContour, ROIContourData) {\n  let { ROIDisplayColor, RecommendedDisplayCIELabValue } = ROIContour;\n\n  if (!ROIDisplayColor && RecommendedDisplayCIELabValue) {\n    // If ROIDisplayColor is absent, try using the RecommendedDisplayCIELabValue color.\n    ROIDisplayColor = dicomlab2RGB(RecommendedDisplayCIELabValue);\n  }\n\n  if (ROIDisplayColor) {\n    ROIContourData.colorArray = [...ROIDisplayColor];\n  }\n}\n\nfunction _setROIContourRTROIObservations(\n  ROIContourData,\n  RTROIObservationsSequence,\n  ROINumber\n) {\n  const RTROIObservations = RTROIObservationsSequence.find(\n    RTROIObservations => RTROIObservations.ReferencedROINumber === ROINumber\n  );\n\n  if (RTROIObservations) {\n    // Deep copy so we don't keep the reference to the dcmjs dataset entry.\n    const {\n      ObservationNumber,\n      ROIObservationDescription,\n      RTROIInterpretedType,\n      ROIInterpreter,\n    } = RTROIObservations;\n\n    ROIContourData.RTROIObservations = {\n      ObservationNumber,\n      ROIObservationDescription,\n      RTROIInterpretedType,\n      ROIInterpreter,\n    };\n  }\n}\n\nfunction _toArray(objOrArray) {\n  return Array.isArray(objOrArray) ? objOrArray : [objOrArray];\n}\n","import { utils } from '@ohif/core';\n\nimport { SOPClassHandlerId } from './id';\nimport loadRTStruct from './loadRTStruct';\n\nconst sopClassUids = ['1.2.840.10008.5.1.4.1.1.481.3'];\n\nlet loadPromises = {};\n\nfunction _getDisplaySetsFromSeries(\n  instances,\n  servicesManager,\n  extensionManager\n) {\n  const instance = instances[0];\n\n  const {\n    StudyInstanceUID,\n    SeriesInstanceUID,\n    SOPInstanceUID,\n    SeriesDescription,\n    SeriesNumber,\n    SeriesDate,\n    SOPClassUID,\n    wadoRoot,\n    wadoUri,\n    wadoUriRoot,\n  } = instance;\n\n  const displaySet = {\n    Modality: 'RTSTRUCT',\n    loading: false,\n    isReconstructable: false, // by default for now since it is a volumetric SEG currently\n    displaySetInstanceUID: utils.guid(),\n    SeriesDescription,\n    SeriesNumber,\n    SeriesDate,\n    SOPInstanceUID,\n    SeriesInstanceUID,\n    StudyInstanceUID,\n    SOPClassHandlerId,\n    SOPClassUID,\n    referencedImages: null,\n    referencedSeriesInstanceUID: null,\n    referencedDisplaySetInstanceUID: null,\n    isDerivedDisplaySet: true,\n    isLoaded: false,\n    isHydrated: false,\n    structureSet: null,\n    sopClassUids,\n    instance,\n    wadoRoot,\n    wadoUriRoot,\n    wadoUri,\n    isOverlayDisplaySet: true,\n  };\n\n  let referencedSeriesSequence = instance.ReferencedSeriesSequence;\n  if (\n    instance.ReferencedFrameOfReferenceSequence &&\n    !instance.ReferencedSeriesSequence\n  ) {\n    instance.ReferencedSeriesSequence = _deriveReferencedSeriesSequenceFromFrameOfReferenceSequence(\n      instance.ReferencedFrameOfReferenceSequence\n    );\n    referencedSeriesSequence = instance.ReferencedSeriesSequence;\n  }\n\n  if (!referencedSeriesSequence) {\n    throw new Error('ReferencedSeriesSequence is missing for the RTSTRUCT');\n  }\n\n  const referencedSeries = referencedSeriesSequence[0];\n\n  displaySet.referencedImages =\n    instance.ReferencedSeriesSequence.ReferencedInstanceSequence;\n  displaySet.referencedSeriesInstanceUID = referencedSeries.SeriesInstanceUID;\n\n  displaySet.getReferenceDisplaySet = () => {\n    const { DisplaySetService } = servicesManager.services;\n    const referencedDisplaySets = DisplaySetService.getDisplaySetsForSeries(\n      displaySet.referencedSeriesInstanceUID\n    );\n\n    if (!referencedDisplaySets || referencedDisplaySets.length === 0) {\n      throw new Error('Referenced DisplaySet is missing for the RT');\n    }\n\n    const referencedDisplaySet = referencedDisplaySets[0];\n\n    displaySet.referencedDisplaySetInstanceUID =\n      referencedDisplaySet.displaySetInstanceUID;\n\n    return referencedDisplaySet;\n  };\n\n  displaySet.load = ({ headers }) =>\n    _load(displaySet, servicesManager, extensionManager, headers);\n\n  return [displaySet];\n}\n\nfunction _load(rtDisplaySet, servicesManager, extensionManager, headers) {\n  const { SOPInstanceUID } = rtDisplaySet;\n  const { segmentationService } = servicesManager.services;\n  if (\n    (rtDisplaySet.loading || rtDisplaySet.isLoaded) &&\n    loadPromises[SOPInstanceUID] &&\n    _segmentationExistsInCache(rtDisplaySet, segmentationService)\n  ) {\n    return loadPromises[SOPInstanceUID];\n  }\n\n  rtDisplaySet.loading = true;\n\n  // We don't want to fire multiple loads, so we'll wait for the first to finish\n  // and also return the same promise to any other callers.\n  loadPromises[SOPInstanceUID] = new Promise(async (resolve, reject) => {\n    if (!rtDisplaySet.structureSet) {\n      const structureSet = await loadRTStruct(\n        extensionManager,\n        rtDisplaySet,\n        rtDisplaySet.getReferenceDisplaySet(),\n        headers\n      );\n\n      rtDisplaySet.structureSet = structureSet;\n    }\n\n    const suppressEvents = true;\n    segmentationService\n      .createSegmentationForRTDisplaySet(rtDisplaySet, null, suppressEvents)\n      .then(() => {\n        rtDisplaySet.loading = false;\n        resolve();\n      })\n      .catch(error => {\n        rtDisplaySet.loading = false;\n        reject(error);\n      });\n  });\n\n  return loadPromises[SOPInstanceUID];\n}\n\nfunction _deriveReferencedSeriesSequenceFromFrameOfReferenceSequence(\n  ReferencedFrameOfReferenceSequence\n) {\n  const ReferencedSeriesSequence = [];\n\n  ReferencedFrameOfReferenceSequence.forEach(referencedFrameOfReference => {\n    const { RTReferencedStudySequence } = referencedFrameOfReference;\n\n    RTReferencedStudySequence.forEach(rtReferencedStudy => {\n      const { RTReferencedSeriesSequence } = rtReferencedStudy;\n\n      RTReferencedSeriesSequence.forEach(rtReferencedSeries => {\n        const ReferencedInstanceSequence = [];\n        const { ContourImageSequence, SeriesInstanceUID } = rtReferencedSeries;\n\n        ContourImageSequence.forEach(contourImage => {\n          ReferencedInstanceSequence.push({\n            ReferencedSOPInstanceUID: contourImage.ReferencedSOPInstanceUID,\n            ReferencedSOPClassUID: contourImage.ReferencedSOPClassUID,\n          });\n        });\n\n        const referencedSeries = {\n          SeriesInstanceUID,\n          ReferencedInstanceSequence,\n        };\n\n        ReferencedSeriesSequence.push(referencedSeries);\n      });\n    });\n  });\n\n  return ReferencedSeriesSequence;\n}\n\nfunction _segmentationExistsInCache(rtDisplaySet, segmentationService) {\n  // Todo: fix this\n  return false;\n  // This should be abstracted with the CornerstoneCacheService\n  const rtContourId = rtDisplaySet.displaySetInstanceUID;\n  const contour = segmentationService.getContour(rtContourId);\n\n  return contour !== undefined;\n}\n\nfunction getSopClassHandlerModule({ servicesManager, extensionManager }) {\n  return [\n    {\n      name: 'dicom-rt',\n      sopClassUids,\n      getDisplaySetsFromSeries: instances => {\n        return _getDisplaySetsFromSeries(\n          instances,\n          servicesManager,\n          extensionManager\n        );\n      },\n    },\n  ];\n}\n\nexport default getSopClassHandlerModule;\n","import { id } from './id';\nimport React from 'react';\nimport { Types } from '@ohif/core';\nimport getSopClassHandlerModule from './getSopClassHandlerModule';\n\nconst Component = React.lazy(() => {\n  return import(\n    /* webpackPrefetch: true */ './viewports/OHIFCornerstoneRTViewport'\n  );\n});\n\nconst OHIFCornerstoneRTViewport = props => {\n  return (\n    <React.Suspense fallback={<div>Loading...</div>}>\n      <Component {...props} />\n    </React.Suspense>\n  );\n};\n\n/**\n * You can remove any of the following modules if you don't need them.\n */\nconst extension: Types.Extensions.Extension = {\n  /**\n   * Only required property. Should be a unique value across all extensions.\n   * You ID can be anything you want, but it should be unique.\n   */\n  id,\n\n  /**\n   * PanelModule should provide a list of panels that will be available in OHIF\n   * for Modes to consume and render. Each panel is defined by a {name,\n   * iconName, iconLabel, label, component} object. Example of a panel module\n   * is the StudyBrowserPanel that is provided by the default extension in OHIF.\n   */\n  getViewportModule({\n    servicesManager,\n    extensionManager,\n  }: Types.Extensions.ExtensionParams) {\n    const ExtendedOHIFCornerstoneRTViewport = props => {\n      return (\n        <OHIFCornerstoneRTViewport\n          servicesManager={servicesManager}\n          extensionManager={extensionManager}\n          {...props}\n        />\n      );\n    };\n\n    return [{ name: 'dicom-rt', component: ExtendedOHIFCornerstoneRTViewport }];\n  },\n  /**\n   * SopClassHandlerModule should provide a list of sop class handlers that will be\n   * available in OHIF for Modes to consume and use to create displaySets from Series.\n   * Each sop class handler is defined by a { name, sopClassUids, getDisplaySetsFromSeries}.\n   * Examples include the default sop class handler provided by the default extension\n   */\n  getSopClassHandlerModule,\n};\n\nexport default extension;\n"],"names":["id","packageJson","SOPClassHandlerId","DicomMessage","DicomMetaDictionary","dcmjs","dicomlab2RGB","Colors","async","loadRTStruct","extensionManager","rtStructDisplaySet","referencedDisplaySet","headers","utilityModule","getModuleEntry","dataSource","getActiveDataSource","bulkDataURI","getConfig","dicomLoaderService","exports","imageIdSopInstanceUidPairs","images","map","image","imageId","sopInstanceUID","SOPInstanceUID","_getImageIdSopInstanceUidPairsForDisplaySet","isLoaded","instance","enabled","datasource","ROIContourSequence","Promise","reject","promisesMap","Map","ROIContour","referencedROINumber","ReferencedROINumber","ContourSequence","Contour","ContourData","contourData","Array","isArray","has","get","push","resolve","set","BulkDataURI","retrieve","bulkDataPromise","StudyInstanceUID","SeriesInstanceUID","resolvedPromisesMap","key","promiseArray","entries","allSettled","forEach","resolvedPromises","index","promise","status","value","every","Number","isFinite","uint8Array","Uint8Array","dataUint8Array","TextDecoder","decode","includes","split","parseFloat","console","error","reason","checkAndLoadContourData","segArrayBuffer","findDicomDataPromise","dicomData","readFile","rtStructDataset","naturalizeDataset","dict","_meta","namifyDataset","meta","StructureSetROISequence","RTROIObservationsSequence","structureSet","StructureSetLabel","ROIContours","visible","i","length","isSupported","ContourSequenceArray","objOrArray","contourPoints","c","ContourImageSequence","NumberOfContourPoints","ContourGeometricType","ReferencedSOPInstanceUID","_getImageId","points","p","x","y","z","numberOfPoints","type","_setROIContourMetadata","imageIdSopInstanceUidPairsEntry","find","StructureSetROI","structureSetROI","ROINumber","ROIContourData","ROIName","ROIGenerationAlgorithm","ROIDescription","ROIDisplayColor","RecommendedDisplayCIELabValue","colorArray","_setROIContourDataColor","RTROIObservations","ObservationNumber","ROIObservationDescription","RTROIInterpretedType","ROIInterpreter","_setROIContourRTROIObservations","sopClassUids","loadPromises","_getDisplaySetsFromSeries","instances","servicesManager","SeriesDescription","SeriesNumber","SeriesDate","SOPClassUID","wadoRoot","wadoUri","wadoUriRoot","displaySet","Modality","loading","isReconstructable","displaySetInstanceUID","utils","guid","referencedImages","referencedSeriesInstanceUID","referencedDisplaySetInstanceUID","isDerivedDisplaySet","isHydrated","isOverlayDisplaySet","referencedSeriesSequence","ReferencedSeriesSequence","ReferencedFrameOfReferenceSequence","referencedFrameOfReference","RTReferencedStudySequence","rtReferencedStudy","RTReferencedSeriesSequence","rtReferencedSeries","ReferencedInstanceSequence","contourImage","ReferencedSOPClassUID","referencedSeries","_deriveReferencedSeriesSequenceFromFrameOfReferenceSequence","Error","getReferenceDisplaySet","DisplaySetService","services","referencedDisplaySets","getDisplaySetsForSeries","load","_ref","rtDisplaySet","segmentationService","suppressEvents","createSegmentationForRTDisplaySet","then","catch","_load","_ref2","name","getDisplaySetsFromSeries","Component","React","OHIFCornerstoneRTViewport","props","fallback","getViewportModule","component","_extends","getSopClassHandlerModule"],"sourceRoot":""}